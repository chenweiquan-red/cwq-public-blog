export const data = JSON.parse("{\"key\":\"v-296636ca\",\"path\":\"/posts/java/collection/concurrentHashMap.html\",\"title\":\"ConcurrentHashMap\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"ConcurrentHashMap\",\"icon\":\"fire\",\"category\":[\"java\"],\"tag\":[\"集合\"],\"description\":\"ConcurrentHashMap 的前因后果 1、ConcurrentHashMap 作用 concurrentHashMap 首先是线程安全的，与之相反的是hashMap非线程安全，还有与之类似的hashTable。 主要作用是再扩容或者新增的过程中保证线程安全， 插入的元素不丢失，获取元素时不报错。 不会像hashMap在扩容过程中， 形成环形链表，导致查询数据时报错。 hashMap的插入逻辑代码截图：\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://github.com/chenweiquan-red/posts/java/collection/concurrentHashMap.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"WQ-知识库\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"ConcurrentHashMap\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"ConcurrentHashMap 的前因后果 1、ConcurrentHashMap 作用 concurrentHashMap 首先是线程安全的，与之相反的是hashMap非线程安全，还有与之类似的hashTable。 主要作用是再扩容或者新增的过程中保证线程安全， 插入的元素不丢失，获取元素时不报错。 不会像hashMap在扩容过程中， 形成环形链表，导致查询数据时报错。 hashMap的插入逻辑代码截图：\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2024-07-13T08:44:34.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Durant\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"集合\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2024-07-13T08:44:34.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"ConcurrentHashMap\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":\\\"2024-07-13T08:44:34.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Durant\\\",\\\"url\\\":\\\"https://www.wqknowledge.top/\\\"}]}\"]]},\"headers\":[{\"level\":3,\"title\":\"1、ConcurrentHashMap 作用\",\"slug\":\"_1、concurrenthashmap-作用\",\"link\":\"#_1、concurrenthashmap-作用\",\"children\":[]},{\"level\":3,\"title\":\"2、ConcurrentHashMap 1.8变化\",\"slug\":\"_2、concurrenthashmap-1-8变化\",\"link\":\"#_2、concurrenthashmap-1-8变化\",\"children\":[]},{\"level\":3,\"title\":\"3、ConcurrentHashMap 思考\",\"slug\":\"_3、concurrenthashmap-思考\",\"link\":\"#_3、concurrenthashmap-思考\",\"children\":[]},{\"level\":3,\"title\":\"4、ConcurrentHashMap 总结\",\"slug\":\"_4、concurrenthashmap-总结\",\"link\":\"#_4、concurrenthashmap-总结\",\"children\":[]}],\"git\":{\"createdTime\":1720860274000,\"updatedTime\":1720860274000,\"contributors\":[{\"name\":\"chenweiquan-red\",\"email\":\"1271288660@qq.com\",\"commits\":1}]},\"readingTime\":{\"minutes\":2.43,\"words\":728},\"filePathRelative\":\"posts/java/collection/concurrentHashMap.md\",\"localizedDate\":\"2024年7月13日\",\"excerpt\":\"<h1> ConcurrentHashMap 的前因后果</h1>\\n<h3> 1、ConcurrentHashMap 作用</h3>\\n<pre><code>concurrentHashMap 首先是线程安全的，与之相反的是hashMap非线程安全，还有与之类似的hashTable。\\n</code></pre>\\n<p>主要作用是再扩容或者新增的过程中保证线程安全， 插入的元素不丢失，获取元素时不报错。</p>\\n<p>不会像hashMap在扩容过程中， 形成环形链表，导致查询数据时报错。</p>\\n<p>hashMap的插入逻辑代码截图：<br>\\n<img src=\\\"https://wqknowledge.oss-cn-shenzhen.aliyuncs.com/collection/hashMap.png\\\" alt=\\\"\\\" loading=\\\"lazy\\\"></p>\",\"autoDesc\":true}")
